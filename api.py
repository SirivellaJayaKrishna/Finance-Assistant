"""
api.py  –  FastAPI wrapper for FinanceService
Drop this file in the project root (same level as services/, database/, etc.)
then run:  uvicorn api:app --reload --port 8000
"""

from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
from datetime import datetime
import sqlite3
import uvicorn

from services.finance_service import FinanceService
from database.db import get_conn, init_db

# ── Boot ──────────────────────────────────────────────────────────────────────
init_db()
service = FinanceService()

app = FastAPI(title="FinTrack API", version="1.0.0")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:5173", "http://localhost:3000", "*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ── Schemas ───────────────────────────────────────────────────────────────────
class SMSRequest(BaseModel):
    sms: str

class BudgetSet(BaseModel):
    category: str
    monthly_limit: float

# ── Endpoints ─────────────────────────────────────────────────────────────────

@app.get("/health")
def health():
    return {"status": "ok", "timestamp": datetime.now().isoformat()}


@app.get("/summary")
def get_summary():
    """Monthly total + per-category breakdown."""
    try:
        total = service.get_monthly_total()

        raw = service.get_category_summary()
        # get_category_summary() returns a DataFrame indexed by category
        if hasattr(raw, "reset_index"):               # DataFrame
            df = raw.reset_index()
            categories = [
                {"name": row["category"], "amount": float(row["total"])}
                for _, row in df.iterrows()
            ]
        elif isinstance(raw, dict):
            categories = [{"name": k, "amount": float(v)} for k, v in raw.items()]
        else:
            categories = []

        return {"monthly_total": float(total), "category_summary": categories}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/transactions")
def get_transactions(limit: int = 30):
    """Most recent expenses from the DB."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "SELECT id, date, amount, merchant, category, payment_mode "
            "FROM expenses ORDER BY id DESC LIMIT ?", (limit,)
        )
        rows = cur.fetchall()
        conn.close()
        return {"transactions": [
            {"id": r[0], "date": r[1][:10], "amount": r[2],
             "merchant": r[3], "category": r[4], "payment_mode": r[5]}
            for r in rows
        ]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/alerts")
def get_alerts(limit: int = 20):
    """Recent alerts generated by the AlertAgent."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "SELECT id, message, created_at FROM alerts ORDER BY id DESC LIMIT ?", (limit,)
        )
        rows = cur.fetchall()
        conn.close()
        return {"alerts": [
            {"id": r[0], "message": r[1], "created_at": r[2]}
            for r in rows
        ]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/budgets")
def get_budgets():
    """All category budget limits."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT category, monthly_limit FROM budgets")
        rows = cur.fetchall()
        conn.close()
        return {"budgets": [{"category": r[0], "monthly_limit": r[1]} for r in rows]}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/budgets")
def set_budget(body: BudgetSet):
    """Insert or update a category budget limit."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute(
            "INSERT INTO budgets(category, monthly_limit) VALUES(?,?) "
            "ON CONFLICT(category) DO UPDATE SET monthly_limit=excluded.monthly_limit",
            (body.category, body.monthly_limit)
        )
        conn.commit()
        conn.close()
        return {"ok": True}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/process-sms")
def process_sms(body: SMSRequest):
    """Run the full LangGraph pipeline on an SMS string."""
    if not body.sms.strip():
        raise HTTPException(status_code=400, detail="SMS cannot be empty")
    try:
        result = service.run_pipeline_from_text(body.sms)
        return result          # already {ok, advisor} or {ok, error}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/stats")
def get_stats():
    """Extra numbers shown on the dashboard overview."""
    try:
        conn = get_conn()
        cur  = conn.cursor()

        cur.execute("SELECT COUNT(*) FROM expenses")
        tx_count = cur.fetchone()[0]

        cur.execute("SELECT AVG(amount) FROM expenses")
        avg_tx = cur.fetchone()[0] or 0

        cur.execute("SELECT MAX(amount) FROM expenses")
        max_tx = cur.fetchone()[0] or 0

        cur.execute("SELECT COUNT(*) FROM alerts")
        alert_count = cur.fetchone()[0]

        conn.close()
        return {
            "transaction_count": tx_count,
            "avg_transaction": round(float(avg_tx), 2),
            "max_transaction": round(float(max_tx), 2),
            "alert_count": alert_count,
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


if __name__ == "__main__":
    uvicorn.run("api:app", host="0.0.0.0", port=8000, reload=True)


@app.delete("/transactions/{transaction_id}")
def delete_transaction(transaction_id: int):
    """Delete a transaction by ID."""
    try:
        conn = get_conn()
        cur = conn.cursor()
        cur.execute("SELECT id FROM expenses WHERE id = ?", (transaction_id,))
        if not cur.fetchone():
            conn.close()
            raise HTTPException(status_code=404, detail="Transaction not found")
        cur.execute("DELETE FROM expenses WHERE id = ?", (transaction_id,))
        conn.commit()
        conn.close()
        return {"ok": True, "deleted_id": transaction_id}
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))